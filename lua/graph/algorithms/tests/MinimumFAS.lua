-- This file is part of Dana.
-- Copyright (C) 2020 Vincent Saulue-Laborde <vincent_saulue@hotmail.fr>
--
-- Dana is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- Dana is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with Dana.  If not, see <https://www.gnu.org/licenses/>.

local DirectedGraph = require("lua/graph/DirectedGraph")
local MinimumFAS = require("lua/graph/algorithms/MinimumFAS")

local checkSequence
local makeId
local setSampleGraphWithCycles

describe("MinimumFAS", function()
    local inputGraph

    before_each(function()
        inputGraph = DirectedGraph.new()
    end)

    after_each(function()
        inputGraph = nil
    end)

    describe("run/constructor", function()
        it("on an acyclic graph", function()
            for i=1,4 do
                inputGraph:addVertexIndex(makeId(i))
            end
            for i=2,4 do
                for j=1,i-1 do
                    inputGraph:addEdge(makeId(i), makeId(j), 1)
                end
            end
            local result = MinimumFAS.run(inputGraph)
            checkSequence(result, 0) -- Optimal solution must be found for acyclic graphs.
        end)

        it("on a graph with a cycle", function()
            setSampleGraphWithCycles(inputGraph)
            local result = MinimumFAS.run(inputGraph)
            checkSequence(result, 101)
        end)
    end)

    it(":removeFeedbackEdges()", function()
        setSampleGraphWithCycles(inputGraph)
        local result = MinimumFAS.run(inputGraph)
        result:removeFeedbackEdges()
        local edgeCount = 0
        for id1,v1 in pairs(inputGraph.vertices) do
            for _ in pairs(v1.outbound) do
                edgeCount = edgeCount + 1
            end
        end
        assert.are.equals(edgeCount, 7)
        assert.is_nil(rawget(inputGraph.vertices["id1"].outbound, "id2"))
    end)
end)

-- Checks the sequence generated by the algorithm.
--
-- Args:
-- * minimumFAS: MinimumFAS containing the sequence to check.
-- * maxRemovedWeight: Expected upper bound of the sum of removed weights.
--
checkSequence = function(minimumFAS, maxRemovedWeight)
    local graph = minimumFAS.graph
    local removedWeight = 0
    local vertexCount = 0
    for id1,v1 in pairs(graph.vertices) do
        local rank1 = minimumFAS.sequence.reverse[id1]
        for id2,edge in pairs(v1.outbound) do
            local rank2 = minimumFAS.sequence.reverse[id2]
            if rank2 < rank1 then
                removedWeight = removedWeight + edge.weight
            end
        end
        vertexCount = vertexCount + 1
    end
    assert.are.equals(minimumFAS.sequence.count, vertexCount)
    assert.is_true(removedWeight <= maxRemovedWeight)
end

-- Creates a string ID for vertex indices from an integer.
--
-- Integers can't be used directly as vertex indices.
--
-- Args:
-- * id: Integer to turn into a vertex index.
--
-- Returns: a string usable as a vertex index.
--
makeId = function(id)
    return "id" .. id
end

-- Fills a DirectedGraph object with hardcoded values.
--
-- Args:
-- * graph: DirectedGraph object to fill.
--
setSampleGraphWithCycles = function(graph)
    graph:addVertexIndex("source")
    graph:addVertexIndex("sink")
    for i=1,4 do
        graph:addVertexIndex("id" .. i)
    end
    graph:addEdge("source", "id4", 1)
    graph:addEdge("source", "id3", 1)
    graph:addEdge("id2", "sink", 1)
    graph:addEdge("id3", "sink", 1)
    for i=1,4 do
        graph:addEdge(makeId(1+(i%4)), makeId(i), 100+i)
    end
end